package com.atguigu.classload;

public class Test {
	public static void main(String[] args) {
		
		Child child = new Child();
		child.function();
		System.out.println("…………………………………………………………………………………………………………………………");
		Child child1 = new Child();
		child1.function();
	}
}
/*
 * 运行Test程序
 * 1.启动JVM虚拟机
 * 2.将Test.java文件编译成Test.class文件，经ClassLoader将Test.class加载到方法区中，在加载过程中将静态内容加载到静态区中
 * 	方法区（Method Area）：供各线程共享的运行时内存区域。它储存了每个类的结构信息，如运行时的常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容。
 * 	上面讲的方法区是规范，在不同虚拟机里头实现是不一样的，最典型的就是永久代(PermGen space)和元空间(Metaspace)。
 * 3.开始运行执行main方法，这时main方法会被JVM调用到Java stack中执行,开辟一段栈空间，从main方法的第一行开始执行
 * 4.在main中，运行new Child(),这时JVM就会在方法区中进行查找有没有被加载到方法区中的Child.class生成的Child Class文件,（查找在方法区中有没有创建对象的模板信息，按照模板信息进行创建对象）
 * 	   如果没有就进行加载Child.class文件，这时Child继承Parent类，所以也要在方法区中进行查找有没有加载Parent.class
 * 	   如果没有也要加载Parent.class
 * 5.Child.class与Parent.class中所有非静态内容会加载到非静态区中，静态内容加载到静态区中（静态变量，静态代码块，静态方法）按书写顺序加载，
 * 	 注：类加载只会执行一次，静态内容也只会执行加载一次，下次再次创建对象是可以直接在方法区中直接获取class信息
 * 6.开始给静态区中的所有静态的成员变量开始默认初始化值。默认初始化之后开始给所有的静态的成员变量显示初始化（默认初始化是变量默认值，而显示初始化是给变量人为赋的初始值）
 * 7.所有静态成员变量显示初始化之后，开始执行静态代码块，先执行父类静态代码块，在执行子类的静态代码块
 * 		注：静态代码只会在类加载的时候执行，类的加载执行一次，所有静态代码也是只执行一次
 * 		注：非静态代码和构造函数中的代码是在对象创建的时候执行的，因此对象创建（new一次），他么就会执行一次（写类中只写静态方法，不写其他方法，不实例化对象，直接用类名调取静态方法）
 * 8.这时Parent.class文件 和 Child.class文件加载完成
 * 9.开始根据方法区中的类的模板信息在堆中创建Child对象，给Child对象在堆中分配内存空间，其实就是分配内存地址，
 * 	
 * 10.开始对类中的的非静态的成员变量开始默认初始化。
 * 11.开始加载对应的构造方法，执行隐式三部
 * 		super();
 * 	  super()是调用父类的构造函数，此处即为Parent的 构造函数，在Parent的构造函数中有个隐式三步：首先是super(),
 * 		再执行Parent的显示初始化（就是由编写的人员 通过语句进行初始化，给变量赋值，如int i = 10），然后执行Parent的非静态构造代码块（代码块），
 * 		最后至执行的Parent的构造函数中的代码
 * 	   说明：虽然Parent没有明写extends，但是我们知道在Java中有个超类Object，它是所有类的父类，因此此处Parent类的super()是调用Object的构造函数
 *	  Parent的执行完之后，回来继续执行Child自己的隐式三步中的第二步：显示初始化，然后执行Child的非静态代码块的，最后执行Child的构造函数中的代码
 * 12.创建对象完成，把堆内存中地址赋给Child类变量child保存到Java Stack中reference里，由指针指向堆内存对象内存空间.//对象创建完成后将Child类变量child保存到Java Stack中reference里，由指针指向堆内存对象内存空间
 * 13.执行child.function();
 * 		栈也叫栈内存，主管java程序的运行，是在线程创建时创建（运行main方法就会创建主线程），他的生命周期是跟随线程的生命周期，线程结束栈内存也就释放，
 * 		对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。8中基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存分配的
 * 		栈存储什么？
 * 		栈帧中主要保存三种数据：
 * 			本地变量（Local Variables）：输入参数和输出参数以及方法内的变量
 * 			栈操作（Operand Stack）：记录出栈、入栈的操作：
 * 			栈帧数据（Frame Date）:包括类文件、方法等等
 * 		栈运行原理：
 *		栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法(Method)和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧 F1，并被压入到栈中，
 *		A方法又调用了 B方法，于是产生栈帧 F2 也被压入栈，
 *		B方法又调用了 C方法，于是产生栈帧 F3 也被压入栈，
 *		……
 *		执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧……		
 *		遵循“先进后出”/“后进先出”原则。		
 *		每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K~756K之间,与等于1Mb左右。
 *		每执行一个方法都会产生一个栈帧，保存到栈(后进先出)的顶部，顶部栈就是当前的方法，该方法执行完毕 后会自动将此栈帧出栈。
 *		
 *		所以在运行main方法时创建主线程就开辟了一块栈空间，在调用child.function()时产生属于function()方法的栈帧进行入栈、压栈、出/弹栈等操作，方法执行完成后进行弹栈，释放空间
 * 14、由于后面又创建(new)了一个新的Child对象，因此重复一下【9】之后的步骤
 * 
 * 
		 * 总结我们知道，我们在创建(new)一个对象的时候，先要去JVM的方法区里获取该对象所对应的类的信息，如果方法区里没有该类的信息，则需要去将它加载进来，加载进来之后，有了该类的信息，我们才能创建一个对象。
		一般，Java类被编译后，会生成一个class文件，在运行的时候会将class文件加载到Java虚拟机JVM中，class文件由类装载器装载，在JVM中（准确的来说应该是在JVM的方法区里）将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数，属性和方法等。一、类的加载过程
		首先，Jvm在执行时，遇到一个新的类时，会到内存中的方法区去找class的信息，如果找到就直接拿来用，如果没有找到，就会去将类文件加载到方法区。在类加载时，静态成员变量加载到方法区的静态区域，非静态成员变量加载到方法区的非静态区域。
		静态代码块是在类加载时自动执行的代码，非静态代码块是在创建对象时自动执行的代码，不创建对象不执行该类的非静态代码块。
		 
		加载过程：
		1、JVM会先去方法区中找有没有相应类的.class存在。如果有，就直接使用；如果没有，则把相关类的.clss加载到方法区。
		2、在.class加载到方法区时，先加载父类再加载子类；先加载静态内容，再加载非静态内容
		3、加载静态内容： 
		把.class中的所有静态内容加载到方法区下的静态区域内
		静态内容加载完成之后，对所有的静态变量进行默认初始化 
		所有的静态变量默认初始化完成之后，再进行显式初始化 
		当静态区域下的所有静态变量显式初始化完后，执行静态代码块 
		4、加载非静态内容：把.class中的所有非静态变量及非静态代码块加载到方法区下的非静态区域内。
		5、执行完之后，整个类的加载就完成了。
		对于静态方法和非静态方法都是被动调用，即系统不会自动调用执行，所以用户没有调用时都不执行，主要区别在于静态方法可以直接用类名直接调用（实例化对象也可以），而非静态方法只能先实例化对象后才能调用。
 * 		
 * 
 *
 * 
 */
